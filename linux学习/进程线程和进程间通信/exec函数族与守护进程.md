#### exec函数族

execl 和execlp

int exec(const char *path,const char *arg,...);

int execlp(const char *file,const chr *arg,...);

成功时执行指定的程序,失败时返回EOF

parh 执行的程序名称,包含路径

arg.. 传递给执行的程序的参数列表

file 执行的程序的名称,在PATH中查找

在 execl() 函数中，最后一个参数必须为 NULL,用于表示参数列表的结束。



execv() 和 execvp() 

这两个函数的区别在于可执行文件的路径的指定方式和参数的传递方式：

int execv(const char *path, char *const argv[])：execv() 函数需要通过完整的文件路径来指定可执行文件。您需要提供可执行文件的完整路径，包括目录和文件名。参数列表作为字符串数组 argv[] 传递给执行的程序。

示例：
#include <unistd.h>

int main() {
    char *const args[] = {"ls", "-l", NULL};
    execv("/bin/ls", args);

    return 0;  // 这一行不会被执行
}在此示例中，execv() 函数将执行位于 /bin/ls 路径下的 ls 程序，并传递 -l 参数以显示详细的文件列表信息。参数列表 args 是一个字符串数组，最后一个元素必须为 NULL。

int execvp(const char *file, char *const argv[])：execvp() 函数允许您直接提供可执行文件的名称，而不需要提供完整的文件路径。它会在系统的 PATH 环境变量所列出的目录中搜索可执行文件。参数列表作为字符串数组 argv[] 传递给执行的程序。

示例：
#include <unistd.h>

int main() {
    char *const args[] = {"ls", "-l", NULL};
    execvp("ls", args);

    return 0;  // 这一行不会被执行
}

在此示例中，execvp() 函数将搜索系统的 PATH 环境变量来查找名为 ls 的可执行文件，并执行它，同时传递 -l 参数以显示详细的文件列表信息。参数列表 args 是一个字符串数组，最后一个元素必须为 NULL。
需要注意的是，这两个函数在执行成功时不会返回，而是直接进入新的可执行文件中。如果执行失败，将会返回一个负数，您可以根据返回值进行错误处理。
总之，execv() 和 execvp() 都是用于执行指定可执行文件的函数，其中 execv() 需要提供完整的文件路径，而 execvp() 则会搜索系统的 PATH 环境变量来找到可执行文件。参数列表需要使用字符串数组方式传递给执行的程序，其中最后一个元素必须为 NULL。



system() 是一个 C 语言标准库函数，用于在操作系统中执行命令。它的原型如下：
int system(const char *command);
system() 函数接受一个参数 command，该参数是一个以 null 结尾的字符串，表示要执行的命令。函数执行成功后，返回一个表示命令执行结果的状态值。
以下是一个示例，展示如何使用 system() 函数执行一个简单的命令：
#include <stdlib.h>

int main() {
    int status;
    status = system("ls -l");

    if (status == -1) {
        // 执行失败
        // 进行错误处理
    } else {
        // 执行成功
        // 处理命令执行结果
    }
    
    return 0;
}
在这个示例中，system("ls -l") 表示执行 ls -l 命令，即列出当前目录下的文件和文件夹的详细信息。system() 函数的返回值被存储在 status 变量中，您可以根据其值来判断命令的执行结果。
需要注意的是，system() 函数会创建一个子进程来执行命令，并且在执行完成后等待命令完成并返回状态。因此，它会阻塞当前进程的执行，直到命令执行完毕。
总结一下，system() 函数用于执行操作系统中的命令。它接受一个以 null 结尾的字符串作为参数，表示要执行的命令。函数会创建一个子进程来执行命令，并在命令完成后返回状态值。您可以根据返回的状态值来判断命令的执行结果。



对于 execl() 函数的第二个参数，它代表命令行参数。通常情况下，第二个参数应该是一个字符串常量，即可执行文件的名称。但是在实际使用时，execl() 并不会验证第二个参数是否与可执行文件的名称完全匹配。
这是因为 execl() 函数的主要目的是执行指定的可执行文件，而不是验证命令行参数的正确性。当 execl() 函数被调用时，它会将第二个参数作为可执行文件的名称来查找并执行对应的程序。
下面是一个示例：
#include <unistd.h>

int main() {
    // 示例：命令行参数乱写
    execl("/bin/ls", "abc", "-l", NULL);

    return 0;  // 这一行不会被执行
}

在这个示例中，execl("/bin/ls", "abc", "-l", NULL) 会尝试执行 /bin/ls 可执行文件。虽然第二个参数 "abc" 并不是 ls 的准确名称，但 execl() 会直接将该参数作为可执行文件的名称来执行。
需要注意的是，尽管 execl() 允许传递任意字符串作为命令行参数，但为了代码的可读性和易于维护，我们通常建议将第二个参数设置为可执行文件的准确名称。这样可以保证代码的可靠性，并且能在阅读代码时直观地了解到要执行的是哪个可执行文件。

#### 守护进程:

守护进程（Daemon Process）是在操作系统中运行的一类特殊类型的进程。它们在后台运行，独立于用户登录会话，并且通常没有与之相关联的终端。
守护进程的主要目的是提供一种长期运行的服务或功能，而不需要用户的交互。它们常常用于后台任务、系统服务和服务器应用程序等场景，在系统启动时就开始运行，并一直保持运行状态，直到系统关闭或被显式停止。
以下是守护进程的一些特点：


运行在后台：守护进程不会与用户登录会话关联，不需用户干预，无需终端输入输出。


没有控制终端：守护进程没有标准输入、输出和错误输出，不会受到终端断开或重新启动的影响。


与会话和终端分离：守护进程通常会调用 setsid() 函数创建一个新的会话，并将自己与当前控制终端分离。


无终止信号：守护进程通常忽略终止信号(SIGHUP, SIGINT等)，以免错误地中断服务。

常见的守护进程包括网络服务、数据库服务、日志监控、定时任务等。它们在系统启动时自动开始运行，并在后台提供服务或执行任务，不需要用户干预。守护进程通常以长期运行的方式，保持对系统资源的监控、提供持续的服务、处理外部请求并响应等。
通过创建守护进程，可以实现后台运行的稳定服务，提供持久的功能和服务能力，在很大程度上增加了系统的可靠性和可用性。

#### 创建守护进程的五个步骤:

创建一个守护进程通常需要进行以下五个步骤：


调用fork()，然后在父进程中退出：这意味着创建一个子进程，并结束父进程。这是为了使子进程独立于终端会话。


调用setsid()创建新的会话：setsid()函数会使子进程成为新的会话领导者，并与当前控制终端脱离关系。这样，守护进程就没有与之关联的控制终端。


关闭标准输入、标准输出和标准错误输出：守护进程不再需要与终端交互，因此需要关闭标准输入（stdin）、标准输出（stdout）和标准错误输出（stderr），以避免对终端的输出。


更改工作目录（可选）：为了避免守护进程占用某个挂载点导致其无法卸载，可以将工作目录更改为其他位置。


重定向文件描述符（可选）：可以将标准输出和标准错误输出重定向到日志文件中，以记录守护进程的输出信息。这样可以方便地查看守护进程的日志和调试信息。

完成上述步骤后，就创建了一个基本的守护进程。



##### setsid() 是一个系统调用函数，用于创建一个新的会话。

在 UNIX 或类 UNIX 系统中，每个进程都属于一个会话（session）。会话是一个或多个进程的组合，通常由一个终端控制。会话中的进程共享一些会话相关的属性，例如控制终端、作业控制等。
setsid() 函数的作用是创建一个新的会话，并使调用它的进程成为该会话的领导者（session leader）。具体来说，它执行以下操作：

如果调用 setsid() 的进程不是一个进程组的组长，那么创建一个新的会话，并使调用进程成为新会话的领导者。
将调用进程的进程组 ID 设置为新会话的会话 ID。
解除与控制终端的关联，使新会话不再有控制终端。

通过调用 setsid() 创建新的会话，可以实现以下效果：

该进程成为新会话的领导者，不再与原始终端相关联。
不再受到终端挂起信号（SIGHUP）的影响，即使终端断开连接，进程也会继续运行。
进程不再拥有控制终端，避免被其他终端操作或终端信号干扰。

setsid() 函数的原型如下：
#include <unistd.h>

pid_t setsid(void);
注意，setsid() 函数只能由非会话组长进程调用，否则将返回错误。因此，在创建守护进程时，通常会先调用 fork() 创建子进程，在子进程中调用 setsid() 来创建新会话并成为会话领导者。