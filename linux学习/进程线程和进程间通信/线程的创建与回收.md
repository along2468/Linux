线程的创建与回收





程序:存放在磁盘上的指令和数据`的有序集合

进程:程序的一次执行过程,是动态的,包括创建\调度\执行和消亡

进程包含了哪些段:

BSS段:BSS 段存储了未初始化的全局变量和静态变量。这些变量在程序加载时会被清零，因此它们的初始值是默认值（通常为0）。

数据段:数据段（Data Segment）：数据段存储了已初始化的全局变量和静态变量。这些变量在程序加载时就已经赋予了初始值，因此数据段在内存中占用的空间是固定的。

代码段:代码段（Text Segment）：也称为程序段或只读代码段，存储了可执行程序的指令集合。代码段通常是只读的，因为它包含了程序的逻辑和操作指令，不允许被修改

堆:堆是动态分配的内存区域，用于存储程序运行时动态分配的内存。堆的大小可以在程序运行过程中动态增长和缩小，由程序员手动管理内存分配和释放。(当进程调用malloc等函数分配内存是,新分配的内存就被动态添加到堆上,当利用free等函数释放内存时,被释放的内存从堆中剔除)

栈: 栈用于存储函数调用、局部变量和返回地址等。栈的大小是固定的，每个函数调用都会在栈上分配一块区域，当函数返回时，分配给该函数的栈区域会被释放。

进程控制块:

PCB（Process Control Block，进程控制块）是操作系统中**用于管理和控制进程的数据结构**。**每个进程都有一个对应的 PCB**，PCB 存储了进程的相关信息，**包括进程的状态、标识符、优先级、程序计数器（PC）、寄存器值、内存分配情况、打开文件列表等**。

PCB 可以看作是操作系统对进程的抽象，它是操作系统进行进程调度和管理的基本单位。当一个进程被创建时，操作系统会为其分配一个 PCB，并将进程的相关信息填充到 PCB 中。当进程被暂停或切换时，操作系统会保存当前进程的上下文信息到对应的 PCB 中，并加载下一个进程的上下文信息。

PCB 中的一些重要字段包括：

1. 进程状态（Process State）：记录进程的当前状态，如运行、就绪、阻塞等。

2. 进程标识符（Process Identifier）：唯一标识一个进程的值，通常是一个整数或字符串。

3. 优先级（Priority）：用于确定进程调度的顺序，具有较高优先级的进程会被优先执行。

4. 程序计数器（Program Counter，PC）：存储当前指令的地址，用于指示下一条将要执行的指令。

5. 寄存器值（Register Values）：保存进程在暂停时的寄存器状态，包括通用寄存器、程序状态字等。

6. 内存分配情况（Memory Allocation）：记录进程所占用的内存地址范围和分配情况。

7. 打开文件列表（Open File List）：记录进程打开的文件和文件描述符。

PCB 的创建、管理和切换由操作系统负责，操作系统通过 PCB 来跟踪和控制进程的执行。通过保存和恢复 PCB 中的上下文信息，操作系统可以实现进程的切换和调度，从而使多个进程能够共享 CPU 资源并实现并发执行。

 进程类型:

交互进程:在shell下启动,以在前台运行,也可以在后台运行

批处理进程:和在终端无关,被提交到一个作业队列中以便顺序执行

守护进程:和终端无关,一直在后台运行



进程状态:

在Linux中，进程的状态可以分为以下几种：

1. 运行（R，Running）：表示进程正在执行或者在可运行队列中等待CPU分配时间片。

2. 就绪（S，Sleeping）：表示进程已经准备好运行，但由于CPU资源有限，暂时还未获得执行的机会。

3. 等待（D，Uninterruptible Sleep）：表示进程由于等待某个事件或资源而暂时停止执行，例如等待磁盘IO、等待网络数据等。这种状态下进程是无法被中断的。

4. 停止（T，Stopped）：表示进程被暂停执行，可以通过发送SIGSTOP或SIGTSTP信号给进程来使其进入停止状态。

5. 僵死（Z，Zombie）：表示进程已经执行完毕，但其父进程尚未对其进行善后处理，即没有调用wait()函数来获取其退出状态。

6. 僵尸停止（X，Dead）：表示进程被暂停执行并且成为僵死进程。

除了上述状态，还有一些特殊的状态：

1. 跟踪（T，Tracing）：表示进程被其他进程追踪，通常用于调试或监控目的。

2. 停止（W，Paging）：表示进程被挂起，等待内存页面交换。

这些状态是动态变化的，进程可以在不同的状态之间切换。可以使用命令如ps、top、htop等来查看进程的状态。





查看进程信息:

ps 查看系统进程快照

top 查看进程动态信息

/proc 查看进程详细信息

  

以下是`ps -elf`命令输出的示例：

```
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S     0     1     0  0  80   0 -  1165 -      13:45 ?        00:00:01 /sbin/init
1 S     0     2     0  0  80   0 -     0 -      13:45 ?        00:00:00 [kthreadd]
1 S     0     3     2  0  80   0 -     0 -      13:45 ?        00:00:00 [rcu_gp]
1 S     0     4     2  0  80   0 -     0 -      13:45 ?        00:00:00 [rcu_par_gp]
1 S     0     6     2  0  80   0 -     0 -      13:45 ?        00:00:00 [kworker/0:0H-kblockd]
```

上面的输出显示了进程的状态（S）、用户ID（UID）、进程ID（PID）、父进程ID（PPID）、CPU使用率（C）、优先级（PRI）、Nice值（NI）、内存使用量（SZ）、进程开始时间（STIME）和命令行参数（CMD) 

nice 按用户指定的优先级运行进程

nice [-n NI值] 命令

NI 范围是-20~19.数值越大优先级越低 ,普通用户调整NI值为0~19,且只能调整自己的进程,只能调高不能降低

root用户可以设定NI为负值,且可调整任何用户

renice 改变正在运行进程的优先级

renice [优先级] PID



jobs  查看后台进程

bg 将挂起的进程在后台运行

fg 把后台运行的进程放到前台运行



子进程是由父进程创建的新进程。在操作系统中，当一个进程通过创建新的进程来执行某个任务时，新创建的进程就成为原进程的子进程。

子进程继承了父进程的一些属性和资源，例如文件描述符、工作目录、用户ID等。但子进程与父进程是独立运行的，它们有自己的执行环境和内存空间。这意味着子进程可以执行不同的程序代码，具有自己的程序执行流程。

子进程的创建通常使用系统调用（例如fork()）来实现。fork()系统调用会创建一个与父进程相同的副本，包括进程的内存内容和状态信息。在fork()调用之后，子进程将继续执行从fork()调用处开始的代码，而父进程和子进程会在该位置分叉，各自独立地继续执行不同的代码路径。

子进程的创建为并发处理提供了一种机制。通过创建多个子进程，可以同时执行多个任务或并行处理多个操作。子进程之间可以独立地执行不同的任务，从而提高系统的并发性和处理能力。

需要注意的是，子进程和父进程之间可以通过进程间通信(IPC)机制进行交互和数据共享。这些机制包括管道、信号、共享内存、消息队列等，使得父子进程之间可以进行数据传递和同步操作





子进程创建:

pid_t fork (void)

创建新的进程,失败返回-1

成功时父进程返回子进程的进程号 子进程返回0

子进程只执行fork()之后的代码

子进程继承了父进程的内容

父子进程有独立的地址空间,互不影响

若父进程先结束,子进程成为孤儿进程,会被init进程收养,变成后台进程

若子进程先结束,父进程如果没有及时回收,子进程变成僵尸进程



  当fork在循环里面时

 在调用fork()之后，操作系统会复制当前进程的所有代码段、数据段和堆栈等，并创建一个全新的子进程。子进程会从fork()调用的位置开始执行，并且会继续执行循环。因此，在一个循环中使用fork()会导致子进程也执行循环。

具体来说，当执行到fork()时，会创建一个新的子进程，并且这个子进程会从fork()的下一条指令开始执行。由于循环中的代码是在fork()之前的部分，所以在子进程中会复制整个循环，导致循环在父进程和子进程中都执行一遍。

如果想要避免子进程中执行循环，可以在fork()之后使用条件语句，让子进程跳过循环的部分，从而在父进程中执行循环，而在子进程中不执行循环。



进程结束:
void exit(int status);

void _exit(int status);

void _Exit(int status);

结束当前进程并将status返回

exit结束进程时会刷新流缓冲区 



进程回收:

pid_t wait(int *status);

- 成功时返回回收的子进程的进程号,失败返回EOF
- 若子进程没有结束,父进程一直阻塞
- 若有多个子进程,哪个先结束就先回收哪个
- status指定报错子进程返回值和结束方式的地址
- status为NULL表示直接释放子进程PCB,不接收返回值 



wait() 函数是一个用于等待子进程终止的系统调用函数。它使得父进程可以暂停执行，并等待子进程的结束。
具体而言，wait() 函数的作用如下：父进程调用 wait() 函数后会被阻塞，直到任意一个子进程结束。
子进程结束时，父进程会从阻塞状态中恢复，并可以获取子进程的终止状态。
如果传递了一个整型指针作为参数，wait() 函数会将子进程的终止状态存储在该指针指向的内存中。



waitpid() 函数是一个系统调用函数，用于等待指定的子进程终止并获取其终止状态。
waitpid() 函数的原型如下：
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
c复制成功复制代码
该函数有三个参数：

pid：指定要等待的子进程的进程 ID。不同的取值对应不同的等待方式：

pid > 0：等待具有指定进程 ID 的子进程。
pid = -1：等待任意子进程，与 wait() 函数的行为相同。
pid = 0：等待与当前进程在同一个进程组的任意子进程。
pid < -1：等待进程组 ID 等于 pid 绝对值的任意子进程。


status：一个指向整型变量的指针，用于存储子进程的终止状态信息。
options：用于指定等待的一些选项，可以使用多个选项通过按位或运算符进行组合。常用的选项包括：

WNOHANG：如果没有子进程已经终止，则立即返回，而不阻塞父进程。此时，waitpid() 的返回值为 0，并且 status 变量不会被修改。
WUNTRACED：如果子进程进入暂停状态（例如收到 SIGSTOP 信号），则立即返回。
WCONTINUED：如果子进程之前被暂停，现在已经恢复运行，则立即返回。

 waitpid() 函数的返回值表示等待的子进程的状态，具体情况如下：

如果调用 waitpid() 时没有指定 WNOHANG 选项，则返回值为终止的子进程的进程 ID。
如果调用 waitpid() 时指定了 WNOHANG 选项，并且没有已经终止的子进程，则返回值为 0。
如果调用 waitpid() 失败，则返回值为 -1，此时可以通过检查 errno 变量来获取失败的原因。

通过使用 waitpid() 函数，父进程可以有更多的灵活性来等待指定的子进程，并根据需要进行处理。常见的用法包括非阻塞等待子进程、等待特定子进程、处理子进程的终止状态等。